/*
 * generated by Xtext
 */
package edu.unq.objetos3.validation

import edu.unq.objetos3.planificacionConferencia.Charla
import edu.unq.objetos3.planificacionConferencia.Debate
import edu.unq.objetos3.planificacionConferencia.PlanificacionConferenciaPackage
import org.eclipse.xtext.validation.Check
import edu.unq.objetos3.planificacionConferencia.Actividad
import edu.unq.objetos3.planificacionConferencia.Model
import edu.unq.objetos3.planificacionConferencia.Espacio
import org.eclipse.emf.common.util.EList
import edu.unq.objetos3.planificacionConferencia.Bloque
import edu.unq.objetos3.planificacionConferencia.Descanso
import edu.unq.objetos3.planificacionConferencia.Almuerzo
import edu.unq.objetos3.planificacionConferencia.Break

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PlanificacionConferenciaValidator extends AbstractPlanificacionConferenciaValidator {
	@Check
	def checkDuracionMinimaCharla(Charla charla) {
		checkDuracionMinima(charla, 30)
	}

	@Check
	def checkDuracionMinimaDebate(Debate debate) {
		checkDuracionMinima(debate, 60)
	}
	
	@Check
	def checkDuracionMinimaBreak(Almuerzo almuerzo) {
		checkDuracionMinima(almuerzo, 45)
	}

	@Check
	def checkDuracionMinimaBreak(Break break) {
		checkDuracionMinima(break, 15)
	}

	@Check
	def checkAlMenosDosOradoresEnDebate(Debate debate) {
		if (debate.oradores.length < 2) {
			error('Un debate tiene que tener al menos 2 oradores', 
					PlanificacionConferenciaPackage.Literals.ACTIVIDAD__ORADORES) 
		}
	}
	
	@Check
	def checkOradoresDeDistintaOrganizacionEnDebate(Debate debate) {
		val cantidadOrganizaciones = debate.oradores.map[organizacion].toSet.length
		
		if (cantidadOrganizaciones < debate.oradores.length) {
			error('Los oradores tienen que ser de distintas organizaciones', 
					PlanificacionConferenciaPackage.Literals.ACTIVIDAD__ORADORES) 
		}
	}
	
	@Check
	def checkExistenLasActividades(Model model) {
		model.espacios.forEach [espacio |
			checkExistenTodasLasCharlas(espacio.actividades.filter(Bloque), model.actividades)
		]
	}
	
	private def checkExistenTodasLasCharlas(Iterable<Bloque> bloques, EList<Actividad> actividades) {
		bloques.forEach [bloque |
			val idsInexistentes = bloque.idsCharlas.filter [idCharla |
				!actividades.exists[id == idCharla]
			]
			
			if (!idsInexistentes.empty)
				error('''No existen las charlas: «idsInexistentes.join(", ")»''',
					bloque,
					PlanificacionConferenciaPackage.Literals.BLOQUE__IDS_CHARLAS)
		]
	}

	private def checkDuracionMinima(Descanso descanso, int duracionMinima) {
		if (descanso.duracion < duracionMinima) {
			error('''No puede durar menos de «duracionMinima» minutos''', 
					PlanificacionConferenciaPackage.Literals.DESCANSO__DURACION) 
		}
	}	
	
	private def checkDuracionMinima(Actividad actividad, int duracionMinima) {
		if (actividad.duracion < duracionMinima) {
			error('''No puede durar menos de «duracionMinima» minutos''', 
					PlanificacionConferenciaPackage.Literals.ACTIVIDAD__DURACION) 
		}
	}	
}
